# Oracle基础笔记
## 一、数据库基础
### 数据库模型
    关系模型：元组、属性、域
        键：超键、候选键、主键、外键
		
### 数据模型
	逻辑模型：主要是在设计阶段绘制E-R图进行设置，代表的是一种逻辑关系
	  E-R图：三要素：实体 属性 联系（一对一 一对多 多对多）
	物理模型：代表具体创建出来的数据库表，是将逻辑模型要转换成物理模型，然后进行建表

### 范式总结
	第一范式（1NF）： 每个属性类型都是原子单值，则关系为第一范式
	第二范式（2NF）： 在上一条基础上排除部分函数依赖，即每个非主属性类型完全依赖于关系的键，则关系为第二范式
	第三范式（3NF）： 在上一条基础上排除传递函数依赖，即每个非主属性类型只依赖键，不依赖其他非主属性，则关系为第三范式
	巴斯范式（BCNF）：在上一条基础上每个非平凡函数依赖X->Y（X不包含Y），X是超键（即X是候选键或其一个超集），则关系为巴斯范式。通俗来说就是消除主属性对于键的部分与传递函数依赖
	第四范式（4NF）： 在上一条基础上若存在平凡多值依赖（当每个X值精确地确定一组Y值时，存在从X到Y，X->->Y的多值依赖性，与其它属性类型无关），对于它的每个非平凡的多值依赖关系X->->Y，X是超键，则关系为第四范式。简单来说就是消除关系中的多对多关系

## 二、SQL
### SQL语言分类
	1.DDL：数据定义语言：主要就是针对数据库对象的创建，修改和删除操作：create alter drop
	2.DML：数据操作语言：主要是用来改变数据库对象中的数据的一种语言，主要关键字：insert update delete
	3.DQL：数据查询语言：是数据库中使用最频繁的语言主要关键字：select
	4.DCL：数据控制语言：主要是针对权限进行操作：grant revoke
	5.TCL：事务控制语言：主要就是针对数据库中的事务操作的语句：commit rollback savepoint
		   事务特性：原子性、一致性、隔离性、持久性

### SQL查询
#### 1.SQL语法及执行顺序
```sql
语法：  
    select [distinct | all] 列名，...|*
    [into 变量]
    from 表名|视图名
    [where 分组后过滤条件]
    [group by 分组字段，...]
    [having 分组过滤]
    [order by 排序字段 [desc|asc]，...]
sql语句的执行顺序：
    from---where---group by---having --- select---order by 
    别名的使用受语句执行的顺序限制
```

#### 2.多表查询
```sql
1.等值连接：where (结果数为关联记录多的结果条数)，为隐式内连接
2.内连接：  [inner] join ...on (结果数为关联记录多的结果条数)
3.外连接：  left   [outer] join ...on (左主右补null，取内连接结果+左表中不相关的条数)
            right [outer] join ...on (右主左补null，取内连接结果+右表中不相关的条数)
            full  [outer] join ...on (左右都补null，取内连接结果+左表中不相关的条数+右表中不相关的条数)
4.自然连接：natural join (自动关联，没有相同的列则笛卡尔积)
5.自连接：	自己连接自己，一般会有一个自引式外键
6.交叉连接：cross join (笛卡尔积)
```

#### 3.子查询
```sql
子查询：子查询不只是在DQL语句中才能使用，根据位置可分为：where之后、from之后、select之后
1.单行子查询：子查询的结果返回一行数据，可以单独执行
    运算符：< > = <= >= != <>

2.多行子查询：子查询的结果返回多行数据，可以单独执行
    运算符：in any all ,=ANY !=all (in 等同于 =any，not in 等同于 <> any)

3.关联子查询：子查询的执行依赖于外查询的对应的条件，不能单独执行
    关键字：[not] exists 
    语法：select * from 表 a where [not] exists (select * from 表 b where 关联字段=a.关联字段);
        例子：查询员工的工资大于他所在部门的平均工资的员工的信息
        select * from emp e where e.sal > (select avg(sal) from emp where deptno=e.deptno);
        例子：查询‘SALES1’和‘RESEARCH’部门的员工信息
        select * from emp e where exists (select * from dept where (dname='SALES1' and dname='RESEARCH') and deptno=e.deptno);
    注意：1.如果子查询数据量比较小，推荐使用in
        2.如果子查询的数据量比较大，推荐使用exists
```

#### 4.表集合操作
```sql
1.并集操作：union [all]
    将两个结果集进行上下合并在一起，设置all则不会去重，一般加上all，效率更高
2.交集操作：intersect 
    返回两个结果集中相同的数据
3.差集操作：minus
    返回第一张表中的和第二张表中不同的数据
注意：操作的结果集必须要有相同的列数
```

#### 5.行转列和列转行
##### 1.行转列：将纵向表转换成横向表
```sql
方式一：使用case when进行转换，需要和group by 和聚合函数结合使用
方式二：使用decode函数进行转换，需要和group by 和聚合函数结合使用
方式三：使用pivot函数进行转换
    pivot函数语法：
        select * from 表 pivot(聚合函数(聚合的字段) for 转成列的列名 in (转成列的值1 别名1, ...)) 
```

##### 2.列转行：将横向表转换成纵向表
```sql
方式一：使用union并集操作进行转换，单独查询每一个列的数据，再合在一起
方式二：使用unpivot函数进行转换
    unpivot函数语法：
        select * from 表 unpivot(自定义列名1 for 自定义列名2 in (原列名1, 原列名2, ...) )
        注意：自定义列名1：代表原来表里面的数据转化之后所在的列名称
            自定义列名2：代表原来表中列名转换之后所在的列的名称
```

#### 6.oracle中伪列
```sql
rowid：索引
rownum：分页
    rownum只支持 <= 和 < 运算符，不支持 = 和 > 运算符，可以取别名存虚表，再使用
注意：Oracle中没有limit这个关键字
```
##### Oracle分页例子
![](2022-10-21-23-02-05.png "Oracle分页实例")

## 三、常用函数
### 字符串函数
#### 1.常用的字符函数
![](2022-10-21-22-32-50.png "常用的字符函数")
### 算术类函数
```sql
round()：四舍五入函数
```
#### 1.常用的数字函数
![](2022-10-21-22-29-21.png "常用的数字函数")

### 转换函数
```sql
cast(列名|值 as 数据类型)：进行数据类型的转换
    转换列
    转换值
    转换一个集合：转化成table collection varray 
        cast(multiset(查询语句) as 数据类型)
```
#### 1.常用的转换函数
![](2022-10-21-22-55-04.png "常用的转换函数")
##### to_char函数常用数字格式化符
![](2022-10-21-22-56-34.png "常用数字格式化符")
### 时间函数
```sql
sysdate：获取系统当前时间(select sysdate from dual;)
    sysdate+1：当前系统时间加一天
    sysdate+1/24：当前系统时间加一小时
    sysdate+1/24/60：当前系统时间加一分钟

last_day(d)：获取指定日期对应的月的最后一天
add_months(d, n)：在指定的日期上加上或者减去n个月
months_between(d1, d2)：查询两个时间之间相差的月份数(d1-d2)，是一个小数

trunc(d, '参数')：截断，截断到指定年、月、季度、周、日的开始时间
    参数：yy mm q day(返回星期天) iw(本周一) ww(上周六)，默认为当天
    例子：明天早上两点
    select trunc(sysdate+1)+1/12 from dual;

extract(参数 from 时间对象|时间戳对象)：获取具体的一个年、月、天
    参数：year month day 对应date对象，hour minute second 对应timestamp对象
    注意：如果截取年月日，对应date类型对象，如果截取时分秒，对应timestamp类型对象
```
#### 1.常用的日期函数
![](2022-10-21-22-32-00.png "常用的日期函数")
### 分支函数
```sql
1.case ...when 
    语法一：case 字段 when 值1 then 语句1
                    when 值2 then 语句2
                    ......
                    else 语句n end;
        注意：该种方式只能进行等值匹配
    语法二：case when 条件1 then 语句1
                when 条件2 then 语句2	  
                ......
                else 语句n end;

2.nvl(字段, 值)：字段为空时返回值，否则返回字段的值
  nvl2(字段, 值1, 值2)：字段为空时返回值2，否则返回值1

3.decode()：只能做等值匹配
    语法一：decode(字段, 值1, 值2, 值3)：如果字段的值=值1，返回值2，否则返回值3
    语法二：decode(字段, 值1, 语句1, 值2, 语句2, ......,值n, 语句n, 语句n+1)：相当于case when语法一
```

### 开窗函数
    开窗函数不影响原数据，是在后面增加了新列，新列中为需要的统计数据
```sql
语法：函数名() over([partition by 分组字段, ...] [order by 分区后排序字段 [desc|asc], ...[定位框架]])
partition by 和 group by 的区别：
    partition by：只能在over窗体中使用，作用是将数据按照指定的字段进行分组，但不会影响原来的数据，只是新增一个窗口列来显示汇总之后的数据
    group by：按照指定的字段进行分组，但只能显示分组后的汇总信息
```

#### 1.开窗函数中可以使用的函数
```sql
聚合函数：count() sum() max() min() avg()
    注意：在使用聚合函数的时候，如果在over里面设置了order by 关键字则代表进行的是累计操作

排名函数：
    rank()：值相等排名相等，后面会留出空位，使用场景(高考分数排名)
    dense_rank()：按等级排名，值相等等级排名相等，后面不会留出空位
    row_number()：顺序排名，值相等也没有重复的排名
    使用场景：
        1.获取某一些小组的前n条数据
        2.统计连续性的问题思路：
            1.使用开窗函数先按照指定的字段分组，然后对该小组的数据使用row_bynber()排名，然后将时间减去名次
            2.如果得到的结果是一样的则代表连续，否则就是不连续
    注意：使用了排名函数时，over()中必须要使用order by子句
    
移动函数：偏移分析函数
    lag(字段, n)： 下移函数，将指定字段值下移n行，在一次查询中取出同一字段的前N行的数据
    lead(字段, n)：上移函数，将指定字段值上移n行，在一次查询中取出同一字段的后N行的数据
    使用场景：同比率(和去年比)、环比率(和上月比)
```
				
#### 2.定位框架
```sql
默认：range between unbounded preceding and current row
语法：range|rows between 边界规则1 adnd 边界规则2
常用的边界规则：
    unbounded preceding：向上一直到第一行
    current row：当前行
    n preceding：向上n行
    unbounded following：向下一直到最后一行
    n following：向下n行
```
									  
### 其他一些分析函数：
```sql
1.listagg()：将一列中的多行数据合并到一行，使用时必须要分组
    语法：listagg(列名, 分隔符) within group(order by 列名)

2.rollup()：对每一个分组的数据进行小计，一般写在group by 后面
    语法：rollup(分组字段, ...)

3.层级关系函数：Oracle中的层级关系使用connect by来实现
    语法：select * [, connect_by_root 字段, ...] from 表 [where 条件] 
            start with 根节点字段 条件 
            connect by prior 编号=子节点字段值
    注意：prior：代表父节点
        connect_by_root 字段：获取层级结构中根节点指定的字段的值
        connect_by_isleaf：原来判断是否是叶子节点(0代表非叶子节点，1代表是叶子节点)
        sys_connect_by_path(字段, 分隔符)：显示节点的完整路径
        level：代表所在层级，根节点为第一层
```
						
### 正则函数
	正则表达式：用来描述一个字符串规则的语法
#### 1.元字符：字母均为小写，大写则为反义字符
代码 | 说明
:---: | :---
.  | 匹配除换行符以外的任意字符
\w | 用来匹配一个数字、字母、下划线、汉字等
\d | 用来匹配数字(0-9)
\s | 用来匹配任意的一个空白符
\b | 用来匹配一个单词的开始或结束
^  | 用来匹配一个字符串的开始(在集合字符里[^a]表示非(不匹配)的意思)
$  | 用来匹配一个字符串的结束

#### 2.反义字符：
代码/语法 | 说明
:---: | :---
\W | 匹配符合元字符\w之外的字符
\D | 用来匹配非数字的字符
\B | 用来匹配不是一个单词的开始和结束
\S | 用来匹配所有的非空白符
[^x] | 用来匹配除了x之外的任意字符
[^abc] | 用来匹配abc之外的任意字符

#### 3.限定符：限定字符或模式重复的次数
代码/语法 | 说明
:---: | :---
* | 前面的字符或者模式出现0次或n次
+ | 前面的字符或者模式出现1次或n次
？| 前面的字符或者模式出现0次或1次
{n}   | 只能出现n次
{n,}  | 至少出现n次
{n,m} |至少出现n次，最多出现m次

#### 4.范围匹配：匹配方括号中的一个字符
	例子：[0-9]：等同于\d

#### 5.字符分支：|  相当于逻辑or
#### 6.字符分组：() 用于多个字符绑定一起重复多次
#### 7.转义字符：\  进行字符转义 
    例如：\n 表示换行符 \t 表示制表符
	如果在一个正则表达式中出现了元字符本身，这时需要使用转义字符来进行转义

#### 8.常用正则表达式函数
```sql
regexp_like(字段, '正则表达式')：进行模糊匹配，功能比like强大
regexp_instr()：在字符串中用来查找正则表达式所描述的字符串所出现的位置
regexp_substr()：在字符串中截取正则表达式所描述的字符串
regexp_count()： 统计字符串中正则表达式所描述的字符串出现的次数	
```		