# PL/SQL基础笔记
PL/SQL编程：是一种过程化语言，专门为Oracle开发的，可以借助于程序分支、循环来实现比较复杂的业务逻辑

## 一、PL/SLQL块的结构
```sql
一个完整的PL/SQL块由三部分组成：
    1.声明部分(可以省略)：declare 	作用：用来声明变量、类型、游标等
    2.执行部分(不可省略)：begin 	    作用：实现程序的核心功能
    3.异常处理(可以省略)：exception   作用：程序执行过程中出现异常时进行的处理
    4.结束部分(不可省略)：end		    作用：表示plsql块执行结束
```

### 完整结构语法
```sql
declare 
    变量声明;
    类型声明;
    游标声明;
    ......
begin 
    具体要执行的代码;
exception 
    when 异常名 then 
        异常处理;
    ......
end;
注意：1.在plsql块中，每一条语句结束时必须要有分号 
    2.使用select ... into 字句必须要保证查询出来的数据有且仅有一条，否则报错
```

### 例子：编写一个plsql块，实现两个数字相加
```sql
declare 
    a int := 10;
    b int := 20;
    c int;
begin 
    c := a + b;
    dbms_output.put_line(c); -- 屏幕输出
end;
```

## 二、PL/SQL中变量和常量的定义
    定义变量作用就是在内存中开辟一块空间来保存数据

### 变量
```sql
变量：
    语法：变量名 数据类型(长度) [:= 初始值];
    注意：1.变量名必须要符合规范，由字母数字下划线组成，数字不打头，同时避免使用关键字
        2.PL/SQL中赋值运算符为 :=
```

### 常量
```sql
常量：如果数据值是固定不变的，可以定义为常量，常量在程序执行过程中不可更改
    语法：常量名 constant 数据类型(长度) := 常量值;
```

### 接收用户键盘输入
```sql
接受用户键盘输入：
    语法：变量名 数据类型 := &变量名(输入的提示)
    注意：如果输入的是一个字符串，必须在&变量名上加引号
```

## 三、PL/SQL中的数据类型：
    作用：在内存中申请空间的时候来限定空间的大小

### 基本数据类型
```sql
1.基本数据类型：
    数值型：number int integer 
    字符串型：char() varchar2() long 
    日期时间类型：date timestamp 
    布尔类型：boolean：true | false 
```

### 特殊数据类型
```sql
2.特殊数据类型：
    1.%type：设置一个变量的数据类型和某一张表中某一个字段数据类型一致
        语法：变量名 表名.字段名%type;
    2.record：记录类型，一种自定义的数量类型，可以将多个变量封装成一个整体
        步骤：
            1.定义一个记录类型
                语法：type 记录类型名称 is record(变量名1 数据类型1, ...);
            2.定义一个记录类型的变量(实例化)
                变量名 记录类型名;
            3.使用记录类型中的子变量：变量名.子变量名
    3.%rowtype：设置一个变量的数据类型和某一张表中记录数据类型一致，相当于%type和record的结合
        语法：变量名 表名%rowtype;
```

## 四、PL/SQL中的流程控制语句：三种程序结构 
### 顺序结构
```sql
1.顺序结构：一般情况下，程序都自动按顺序执行
```

### 分支结构
```sql
2.分支结构：程序在执行过程中根据不同的条件来选择执行不同的代码
    0.if：单分支
        语法：	if 条件 then 
                    条件成立执行的语句;
                end if;
    1.if ...else：双分支
        语法：  if 条件 then 
                    条件成立执行的语句;
                else 
                    条件不成立执行的语句;
                end if;
    2.if ...elsif ...else ...：多分支
        语法：  if 条件1 then 
                    条件成立执行的语句1;
                elsif 条件2 then 
                    条件成立执行的语句2;
                ......
                else 
                    条件不成立执行的语句n;
                end if;
    3.case when ...：多分支
建议：多分支等值匹配时用case when，区间匹配时使用if elsif
注意：分支和循环语句最后需要加上：end 对应语句名
```

### 循环结构
```sql
3.循环结构：三要素：循环变量 循环条件 循环体
    1.loop 
        语法：	loop 
                    循环体
                exit when 循环条件;
                end loop;
    2.while 
        语法：	while 循环条件 loop  
                    循环体
                end loop;
    3.for
        语法：	for 循环变量 in [reverse] 开始..结束|游标 loop 
                    循环体
                end loop;
        
        注意：1.for循环中变量是自动改变的，相当于python中的遍历
            2.如果想让循环变量递减(倒序)，使用reverse参数
    退出循环关键字：exit
```

## 五、游标：cursor
    在SQL语句执行时，系统会自动分配一块空间来保存该SQL语句执行所影响的数据，游标则是指向这块空间的指针

### 显式游标：是由用户自己定义的游标
```sql
作用：主要是用来操作DQL语句执行的结果集
步骤：
    1.定义游标：游标定义必须写在PL/SQL块的声明部分
        语法：cursor 游标名 [(形参列表)] is DQL语句;
    2.打开游标：游标打开操作要写在PL/SQL块的执行部分
        语法：open 游标名 [(参数值)];
        注意：1.一个已经被打开的游标不能被重复打开
            2.如果游标有参数，必须要传入参数
    3.读取游标：读取游标一般是一个循环的过程
        语法：fetch 游标名 into 变量名1, ...;
        注意：读取时需要先打开游标
    4.关闭游标：游标关闭操作要写在PL/SQL块的执行部分
        语法：close 游标名;
        注意：不能关闭一个没有打开的游标
注意：1.使用for循环操作游标时，系统会自动打开、关闭游标
    2.使用for循环操作游标时，系统会自动封装fetch到的结果作为一个循环变量
```

### 隐式游标
```sql
所有的隐式游标统一名称为：sql
作用：主要用来操作DML(insert update delete等)语句，也可以用来操作查询语句(使用for循环)
      Oracle系统中，每执行一条SQL语句，系统都会为该语句自动创建一个游标，为隐式游标
注意：隐式游标永远指向的是最近一条sql语句执行所影响的数据空间
```

### 引用游标：REF游标 
```sql
在一个存储过程中如果要返回一个结果集则需要使用引用游标
游标属性：
    1.%found：判断是否找到数据，返回布尔类型结果：true | false
    2.%notfound：和%found相反，也是返回布尔类型结果：true | false 
    3.%rowcount：返回游标所执行的DQL语句所影响的行数
    4.%isopen：判断游标是否打开，返回布尔类型结果：true | false
```

## 六、异常：exception
### 异常处理语法：
```sql
exception
    when 异常名称1 then 异常处理代码1;
    when 异常名称2 then 异常处理代码2;
    ......
    when others then 异常处理代码n;
注意：others需要放在最后
```

### 异常属性：需要用变量保存，才能使用
```sql
sqlcode：异常编码
sqlerrm：异常信息
注意：实际工作中，所有异常基本上使用others捕获，并获取其编码和信息，保存到日志中
```

### 异常分类：
#### 1.系统预定义异常：
```sql
数据库中已经定义好的异常，可以直接使用(Oracle中20来个)
常见异常：
    1.zero_divide：除数为0异常
    2.no_data_found：当指执行select...into语句时，没有查询到数据
    3.too_many_rows：当指执行select...into语句时，查询到多行数据
    4.cursor_alread_open：试图打开一个已经被打开的游标
    5.invalid_cursor：代表一个非法的游标操作，关闭一个未打开的游标
    6.others：用来捕获所有异常
```
**常见系统异常如下表：**        
![](2022-10-21-14-35-30.png#pic_right "常见系统异常表")

#### 2.用户自定义异常：
```sql
1.错误编号异常：
    将数据库中出现的一些异常编号，和一个异常变量名进行绑定，在后续处理该异常时可以直接使用该异常
    步骤：
        1.定义一个异常变量名
            语法：变量名 exception;
        2.将异常变量名和错误编号进行绑定
            语法：pragma exception_init(异常变量名, 错误编号);
        3.现在进行捕获异常时就可以使用异常变量名来进行处理了
    注意：错误编号异常，其实也算是系统异常，因为异常是由系统引发的，而不是用户主动引发的
        
2.业务逻辑异常：
    用户可以根据自己的业务逻辑需要定义异常，并且在规定时间或特定场景下面去引发
    步骤：
        1.定义一个异常变量
        2.在合适时机引发异常：raise
        3.处理异常：exception
    注意：1.一般情况下，一个PL/SQL块是一个完整的事务逻辑，正常执行完时提交(commit)，异常时回滚(rollback)
        2.主动用raise抛出异常时，必须使用exception对其进行处理
```

## 七、自定义函数：function
### PL/SQL块分类
```sql
匿名PL/SQL块
        1.一个单独的PL/SQL块，没有名称，每次都要选中执行
        2.不能将其作为对象保存到数据库中，无法实现代码重用

命名PL/SQL块
    将一个完整的业务逻辑代码块取一个名称，进行独立编译并且保存到数据库，后续可以调用名称使用该代码块
    常见命名PL/SQL块：函数、存储过程、触发器、程序包等
    优点：
        1.代码的重用性比较高
        2.执行效率比较高：代码执行时不需要再检查和编译
```

### 创建函数
```sql
语法：
    create [or replace] function 函数名[(参数名 参数类型 [default 参数值], ...)] 
    rerurn 数据类型 
    is
    [变量声明
    类型声明
    游标声明]
    begin
        函数体
        return 值;
    [exception
        when 异常名 then
            处理异常代码]
    end [函数名];
注意：1.函数必须要有一个返回值，一般是进行汇总或者统计一个数字时使用
      2.函数创建的过程并不会执行代码，只是检查和编译保存
      3.如果要执行函数中的代码，则必须要对函数进行调用
```

### 调用函数
```sql
1.直接使用select语句进行调用
    注意：一般情况下，调用时需要传入对应参数，默认值参数可不传参
2.使用PL/SQL块调用
```

### 删除函数
```sql
语法：drop function 函数名;
```

## 八、存储过程：procedure
### 8.1 创建存储过程
```sql
create [or replace] procedure 存储过程名[(参数列表)]
is|as
[变量，游标等声明]
begin
    存储过程中需要执行的代码
[exception
    异常处理]
end [存储过程名];
```
注意：
1. 存储过程在创建时只是进行检查和编译，具体的执行需要被调用
2. 存储过程定义时参数只需要指定类型，不需要指定长度

### 8.2 调用存储过程
#### 8.2.1 使用PL/SQL块调用
```sql
declare 
[变量等的声明]
begin
    存储过程名;
[exception
    异常处理]
end;
```
**参数传递**
形参：程序定义时设置的参数，没有具体值，可以设置默认值
实参：程序执行过程中实际传入的参数的值
一般情况下，实参和形参数量保持一致，默认值参数可以不传

**传参方式** 
1. 按照位置进行传参：实参位置和形参位置需保持一致
2. 按照名字进行传参：根据形参名字传入实际参数，位置可以变化
   `传参语法：参数名 => 参数名`
   有默认参数时，不传默认参数，有时候需要指定传入的参数
3. 混合传参：按照位置和名称进行传参，一般使用较少
#### 8.2.2 使用call调用
```sql
call 存储过程名([(参数列表)]);
```

### 8.3 存储过程的参数模式
存储过程有三种参数模式
#### 8.3.1 in 模式：输入参数
输入参数的值只能从外部传入，在存储过程中，不能修改和重新赋值
```sql
参数语法：参数名 [in] 参数类型 [default 值]
```
>注意：一般可以将in关键字省略，默认为输入参数，输入参数可以设置默认值

#### 8.3.2 out 模式：输出参数
输出参数的功能就相当于函数中的return，但是存储过程可以输出多个值
输出参数的值，只能从存储过程内部被赋值，然后传出到存储过程外面
```sql
参数语法：参数名 out 数据类型
```
>注意：存储过程有输出参数时，在调用的时候需要定义变量来接收其返回出来的数据

#### 8.3.3 inout 模式：输入输出参数
输入输出参数具备了输入参数和输出参数的所有特性
```sql
参数语法：参数名 in out 参数类型
```
>注意：输入输出参数不能设置默认值

### 8.4 删除存储过程
```sql
drop procedure 存储过程名;
```

### 8.5 存储过程和函数对比
1. 定义时关键字不一样：`function`和`procedure`
2. 函数必须使用return返回数据，存储过程使用out/in out参数返回数据
3. 函数只能返回一个数据，存储过程可以返回多个数据
4. 调用方式不一样，函数可以用select调用，存储过程可以使用call调用，两者都可以使用PL/SQL块调用
5. 函数的参数只有in模式，存储过程的参数有in/out/in out三种模式

### 8.6 存储过程应用场景
#### 8.6.1 编写存储过程来实现增量和全量导数据
全量抽数：将原表中所有数据全部抽取到目标表中   

    适用场景：表的数据量比较小，或者表中的数据变化很小
    例如：维度表中地区维度、时间维度等
    
    批量添加数据语法：insert inot 表名 select语句;

    过程：
        1.清楚目标表中所有数据（truncate语句需要使用动态SQL执行）
        2.将源表中所有数据批量导入到目标表中（insert语句）
增量抽数：将原表中发生变化的数据抽取到目标表中

    使用场景：表中数据量非常大，并且数据变化速度非常快
    例如：订单事实表、评论事实表等

    前提条件：源表中需要有一个时间字段，来代表数据是否是最新的数据
    过程：
        1.将目标表中指定时间的数据先进行删除（delete）
        2.根据传入的时间来从原表中查询出来发生变化的数据，然后将数据同步到目标表中（merge into）
`merge into`：添加更新，如果目标表中存在该条数据，则进行修改，否则就进行添加，语法如下：
```sql
merge into 目标表 using 原表 on (匹配条件) 
when matched then
    update set (字段1=值1, ...)  -- 匹配成功时操作：update操作
when not matched then
    insert [(列名, ...)] values (值, ...);  -- 匹配失败时操作：insert操作
```   
![merge语句示例](2022-10-24-15-48-02.png "merge语句示例")
 
#### 8.6.2 编写存储过程来实现拉链表（记录历史信息）




## 九、动态SQL
PL/SQL块中一些sql语句不能在一开始就确定，或者是需要执行一些DDL语句的时候，需要用到动态SQL语句
动态SQL语句语法：`execute immediate 'sql语句';`



